> [!NOTE]
> This document is auto-generated by LLM. Errors may exist.

# RESTful API

Boltconn provides a RESTful API for remote control and monitoring. This document describes all available endpoints.

## Configuration

Enable the API server in your configuration:

```yaml
web_controller:
  api_addr: 9000                    # Port or socket address
  api_key: your-secret-key          # Optional authentication
  cors_allowed_list:                # Optional CORS origins
    - "http://localhost:3000"
    - "https://dashboard.example.com"
```

## Authentication

If `api_key` is configured, all requests must include authentication. The exact mechanism depends on the implementation, but typically uses a header or query parameter.

**Example with API key:**

```bash
curl -H "Authorization: Bearer your-secret-key" \
  http://localhost:9000/proxies
```

## CORS

Configure `cors_allowed_list` to allow requests from web applications hosted on different origins.

## WebSocket Endpoints

### GET /ws/traffic

Real-time traffic statistics stream.

**Protocol:** WebSocket

**Description:** Streams traffic statistics every second with upload/download speeds.

**Response Format:**

```json
{
  "upload": 1048576,           // Total uploaded bytes
  "download": 5242880,         // Total downloaded bytes
  "upload_speed": 102400,      // Current upload speed (bytes/sec)
  "download_speed": 524288     // Current download speed (bytes/sec)
}
```

**Example (JavaScript):**

```javascript
const ws = new WebSocket('ws://localhost:9000/ws/traffic');
ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log(`Speed: �${data.upload_speed} �${data.download_speed}`);
};
```

### GET /ws/connections

Real-time connection list stream.

**Protocol:** WebSocket

**Description:** Streams the current list of active connections every second.

**Response Format:**

```json
[
  {
    "conn_id": 12345,
    "inbound": "http:7890",
    "source": "192.168.1.100:54321",
    "destination": "example.com:443",
    "protocol": "tcp",
    "proxy": "my-proxy",
    "process": {
      "pid": 1234,
      "path": "/usr/bin/firefox",
      "name": "firefox",
      "cmdline": "firefox https://example.com",
      "parent_name": "bash"
    },
    "upload": 4096,
    "download": 16384,
    "start_time": 1234567890,
    "active": true
  }
]
```

**Example (JavaScript):**

```javascript
const ws = new WebSocket('ws://localhost:9000/ws/connections');
ws.onmessage = (event) => {
  const connections = JSON.parse(event.data);
  console.log(`Active connections: ${connections.length}`);
};
```

### GET /ws/logs

Real-time log stream.

**Protocol:** WebSocket

**Description:** Streams log messages as text.

**Response Format:** Text messages (one log line per message)

**Example (JavaScript):**

```javascript
const ws = new WebSocket('ws://localhost:9000/ws/logs');
ws.onmessage = (event) => {
  console.log('Log:', event.data);
};
```

## TUN Management

### GET /tun

Get TUN device status.

**Method:** GET

**Response:**

```json
{
  "enabled": true
}
```

**Example:**

```bash
curl http://localhost:9000/tun
```

### PUT /tun

Enable or disable TUN device.

**Method:** PUT

**Request Body:**

```json
{
  "enabled": false
}
```

**Response:**

```json
true
```

Returns `true` on success.

**Example:**

```bash
# Disable TUN
curl -X PUT http://localhost:9000/tun \
  -H "Content-Type: application/json" \
  -d '{"enabled": false}'

# Enable TUN
curl -X PUT http://localhost:9000/tun \
  -H "Content-Type: application/json" \
  -d '{"enabled": true}'
```

## Traffic & Connections

### GET /traffic

Get current traffic statistics.

**Method:** GET

**Response:**

```json
{
  "upload": 1048576,
  "download": 5242880,
  "upload_speed": 102400,
  "download_speed": 524288
}
```

**Example:**

```bash
curl http://localhost:9000/traffic
```

### GET /connections

Get all active connections.

**Method:** GET

**Response:**

```json
[
  {
    "conn_id": 12345,
    "inbound": "http:7890",
    "source": "192.168.1.100:54321",
    "destination": "example.com:443",
    "protocol": "tcp",
    "proxy": "my-proxy",
    "process": {
      "pid": 1234,
      "path": "/usr/bin/firefox",
      "name": "firefox",
      "cmdline": "firefox https://example.com",
      "parent_name": "bash"
    },
    "upload": 4096,
    "download": 16384,
    "start_time": 1234567890,
    "active": true
  }
]
```

**Fields:**
- `conn_id`: Unique connection identifier
- `inbound`: Inbound service (e.g., "http:7890", "socks5:1080", "tun")
- `source`: Source address and port
- `destination`: Destination address and port
- `protocol`: Protocol ("tcp" or "udp")
- `proxy`: Proxy group or name used
- `process`: Process information (may be null)
- `upload`: Uploaded bytes
- `download`: Downloaded bytes
- `start_time`: Unix timestamp
- `active`: Whether connection is still active

**Example:**

```bash
curl http://localhost:9000/connections
```

### DELETE /connections

Stop all active connections.

**Method:** DELETE

**Response:** Empty (HTTP 200)

**Example:**

```bash
curl -X DELETE http://localhost:9000/connections
```

### DELETE /connections/:id

Stop a specific connection.

**Method:** DELETE

**Path Parameter:**
- `id`: Connection ID (u64)

**Response:**

```json
true
```

Returns `true` if successful.

**Example:**

```bash
curl -X DELETE http://localhost:9000/connections/12345
```

### GET /connections/log_limit

Get connection log limit.

**Method:** GET

**Response:**

```json
1000
```

Returns the maximum number of connections to keep in history.

**Example:**

```bash
curl http://localhost:9000/connections/log_limit
```

### PUT /connections/log_limit

Set connection log limit.

**Method:** PUT

**Request Body:** Number (u32)

**Example:**

```bash
curl -X PUT http://localhost:9000/connections/log_limit \
  -H "Content-Type: application/json" \
  -d '500'
```

## Sessions

### GET /sessions

Get active UDP sessions.

**Method:** GET

**Response:**

```json
[
  {
    "pair": "192.168.1.100:54321 -> 8.8.8.8:53",
    "time": 1234567890,
    "tcp_open": false
  }
]
```

**Fields:**
- `pair`: Source and destination addresses
- `time`: Last activity timestamp
- `tcp_open`: Whether TCP connection is open

**Example:**

```bash
curl http://localhost:9000/sessions
```

## HTTP Interception

### GET /intercept/all

Get all intercepted HTTP requests.

**Method:** GET

**Response:**

```json
[
  {
    "id": 1,
    "request_url": "https://api.example.com/users",
    "request_method": "GET",
    "response_status": 200,
    "timestamp": 1234567890
  }
]
```

**Example:**

```bash
curl http://localhost:9000/intercept/all
```

### GET /intercept/range

Get intercepted requests in a range.

**Method:** GET

**Query Parameters:**
- `start`: Start index (u32, required)
- `end`: End index (u32, optional)

**Response:** Same format as `/intercept/all`

**Example:**

```bash
# Get requests 0-99
curl http://localhost:9000/intercept/range?start=0&end=100

# Get all requests from index 100
curl http://localhost:9000/intercept/range?start=100
```

### GET /intercept/payload/:id

Get full intercepted request and response.

**Method:** GET

**Path Parameter:**
- `id`: Intercept ID (usize)

**Response:**

```json
{
  "req_header": "GET /users HTTP/1.1\r\nHost: api.example.com\r\n...",
  "req_body": {
    "Body": {
      "content": "base64-encoded-body"
    }
  },
  "resp_header": "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n...",
  "resp_body": {
    "Body": {
      "content": "base64-encoded-body"
    }
  }
}
```

**Body Types:**
- `"Empty"`: No body
- `{"Warning": {"content": "..."}}`: Warning message (e.g., "Too large")
- `{"Body": {"content": "..."}}`: Base64-encoded body content

**Example:**

```bash
curl http://localhost:9000/intercept/payload/1
```

## Proxy Management

### GET /proxies

Get all proxy groups.

**Method:** GET

**Response:**

```json
[
  {
    "name": "Proxy",
    "selected": "my-proxy",
    "list": [
      {
        "name": "my-proxy",
        "proto": "socks5",
        "latency": 50
      },
      {
        "name": "DIRECT",
        "proto": "direct",
        "latency": 0
      }
    ]
  }
]
```

**Fields:**
- `name`: Proxy group name
- `selected`: Currently selected proxy
- `list`: Available proxies in group
  - `name`: Proxy name
  - `proto`: Proxy protocol type
  - `latency`: Latency in milliseconds (null if not tested)

**Example:**

```bash
curl http://localhost:9000/proxies
```

### GET /proxies/:group

Get specific proxy group.

**Method:** GET

**Path Parameter:**
- `group`: Proxy group name

**Response:**

```json
{
  "name": "Proxy",
  "selected": "my-proxy",
  "list": [
    {
      "name": "my-proxy",
      "proto": "socks5",
      "latency": 50
    }
  ]
}
```

**Example:**

```bash
curl http://localhost:9000/proxies/Proxy
```

### PUT /proxies/:group

Set selected proxy for a group.

**Method:** PUT

**Path Parameter:**
- `group`: Proxy group name

**Request Body:**

```json
{
  "selected": "my-proxy"
}
```

**Response:**

```json
true
```

Returns `true` if successful.

**Example:**

```bash
curl -X PUT http://localhost:9000/proxies/Proxy \
  -H "Content-Type: application/json" \
  -d '{"selected": "DIRECT"}'
```

### GET /speedtest/:group

Trigger latency test for proxy group.

**Method:** GET

**Path Parameter:**
- `group`: Proxy group name

**Description:** Initiates latency testing for all proxies in the group. Results are updated in the proxy list and can be retrieved via `/proxies/:group`.

**Response:**

```json
true
```

Returns `true` if speedtest was initiated.

**Example:**

```bash
# Start speedtest
curl http://localhost:9000/speedtest/Proxy

# Wait a few seconds, then check results
curl http://localhost:9000/proxies/Proxy
```

## Master Connections

Master connections are persistent connections for protocols like WireGuard and SSH.

### GET /connections/master

Get master connection status.

**Method:** GET

**Response:**

```json
[
  {
    "name": "my-wg",
    "alive": true,
    "last_active": 1234567890,
    "last_handshake": 1234567880,
    "hand_shake_is_expired": false
  }
]
```

**Fields:**
- `name`: Connection name (proxy name)
- `alive`: Whether connection is alive
- `last_active`: Last activity timestamp
- `last_handshake`: Last handshake timestamp (WireGuard only)
- `hand_shake_is_expired`: Whether handshake is expired (WireGuard only)

**Example:**

```bash
curl http://localhost:9000/connections/master
```

### DELETE /connections/master/:id

Stop a master connection.

**Method:** DELETE

**Path Parameter:**
- `id`: Connection name (string)

**Example:**

```bash
curl -X DELETE http://localhost:9000/connections/master/my-wg
```

## DNS Utilities

### GET /dns/mapping/:fake_ip

Resolve fake IP to real domain.

**Method:** GET

**Path Parameter:**
- `fake_ip`: Fake IP address

**Response:**

```json
"example.com"
```

Returns the domain name or `null` if not found.

**Example:**

```bash
curl http://localhost:9000/dns/mapping/198.18.0.1
```

### GET /dns/lookup/:domain

Perform real DNS lookup.

**Method:** GET

**Path Parameter:**
- `domain`: Domain name to resolve

**Response:**

```json
"1.2.3.4"
```

Returns the IP address or `null` if lookup failed.

**Example:**

```bash
curl http://localhost:9000/dns/lookup/example.com
```

## System

### POST /reload

Reload configuration.

**Method:** POST

**Description:** Reloads the configuration file without restarting the process. Some changes may require a full restart.

**Response:** Empty (HTTP 200)

**Example:**

```bash
curl -X POST http://localhost:9000/reload
```

## Complete API Examples

### Monitor Traffic in Shell

```bash
# Using websocat (WebSocket client)
websocat ws://localhost:9000/ws/traffic | while read line; do
  echo "$(date): $line"
done
```

### Change Proxy Selection

```bash
#!/bin/bash

# Get current selection
CURRENT=$(curl -s http://localhost:9000/proxies/Proxy | jq -r '.selected')
echo "Current proxy: $CURRENT"

# List available proxies
curl -s http://localhost:9000/proxies/Proxy | jq -r '.list[].name'

# Switch to DIRECT
curl -X PUT http://localhost:9000/proxies/Proxy \
  -H "Content-Type: application/json" \
  -d '{"selected": "DIRECT"}'

echo "Switched to DIRECT"
```

### Find Fastest Proxy

```bash
#!/bin/bash

GROUP="Proxy"

# Trigger speedtest
curl -s http://localhost:9000/speedtest/$GROUP

# Wait for tests to complete
sleep 5

# Get fastest proxy
FASTEST=$(curl -s http://localhost:9000/proxies/$GROUP | \
  jq -r '.list | map(select(.latency != null)) | sort_by(.latency) | .[0].name')

# Set as selected
curl -X PUT http://localhost:9000/proxies/$GROUP \
  -H "Content-Type: application/json" \
  -d "{\"selected\": \"$FASTEST\"}"

echo "Selected fastest proxy: $FASTEST"
```

### Monitor Connections

```bash
#!/bin/bash

# Get active connections
CONNECTIONS=$(curl -s http://localhost:9000/connections)

# Count by proxy
echo "$CONNECTIONS" | jq -r '.[].proxy' | sort | uniq -c

# List processes
echo "$CONNECTIONS" | jq -r '.[].process.name' | sort | uniq -c

# Total traffic
UPLOAD=$(echo "$CONNECTIONS" | jq '[.[].upload] | add')
DOWNLOAD=$(echo "$CONNECTIONS" | jq '[.[].download] | add')

echo "Total Upload: $UPLOAD bytes"
echo "Total Download: $DOWNLOAD bytes"
```

### Kill High-Bandwidth Connections

```bash
#!/bin/bash

THRESHOLD=10485760  # 10 MB

curl -s http://localhost:9000/connections | \
  jq -r ".[] | select(.download > $THRESHOLD) | .conn_id" | \
  while read id; do
    echo "Killing connection $id"
    curl -X DELETE http://localhost:9000/connections/$id
  done
```

### Check Master Connection Health

```bash
#!/bin/bash

# Get master connections
MASTERS=$(curl -s http://localhost:9000/connections/master)

# Check health
echo "$MASTERS" | jq -r '.[] | "\(.name): alive=\(.alive), expired=\(.hand_shake_is_expired)"'

# Restart expired WireGuard connections
echo "$MASTERS" | jq -r '.[] | select(.hand_shake_is_expired == true) | .name' | \
  while read name; do
    echo "Restarting expired connection: $name"
    curl -X DELETE http://localhost:9000/connections/master/$name
  done
```

### Inspect Intercepted HTTP Traffic

```bash
#!/bin/bash

# Get recent intercepts
INTERCEPTS=$(curl -s "http://localhost:9000/intercept/range?start=0&end=10")

# List URLs
echo "$INTERCEPTS" | jq -r '.[] | "\(.id): \(.request_method) \(.request_url) [\(.response_status)]"'

# Get full payload for specific request
ID=1
PAYLOAD=$(curl -s "http://localhost:9000/intercept/payload/$ID")

# Decode request body
echo "$PAYLOAD" | jq -r '.req_body.Body.content' | base64 -d

# Decode response body
echo "$PAYLOAD" | jq -r '.resp_body.Body.content' | base64 -d
```

## Error Responses

API endpoints may return error responses:

```json
{
  "error": "Error message"
}
```

Common HTTP status codes:
- `200 OK` - Success
- `400 Bad Request` - Invalid request parameters
- `401 Unauthorized` - Authentication failed
- `404 Not Found` - Resource not found
- `500 Internal Server Error` - Server error

## Rate Limiting

The API does not implement rate limiting by default, but you should avoid making excessive requests, especially to WebSocket endpoints.

## Security Considerations

1. **API Key:** Always use an `api_key` when the API is accessible from untrusted networks
2. **CORS:** Restrict `cors_allowed_list` to trusted origins only
3. **Bind Address:** Bind to `127.0.0.1` if only local access is needed
4. **HTTPS:** Consider using a reverse proxy with HTTPS for production deployments

**Example secure configuration:**

```yaml
web_controller:
  api_addr: 127.0.0.1:9000  # Local only
  api_key: $(openssl rand -base64 32)
  cors_allowed_list:
    - "https://dashboard.example.com"
```
